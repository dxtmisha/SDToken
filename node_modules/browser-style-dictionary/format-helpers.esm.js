import require$$0 from 'change-case';

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const defaultFormatting$2 = {
  prefix: '',
  commentStyle: 'long',
  indentation: '',
  separator: ' =',
  suffix: ';'
};

/**
 * Creates a function that can be used to format a property. This can be useful
 * to use as the function on `dictionary.allTokens.map`. The formatting
 * is configurable either by supplying a `format` option or a `formatting` object
 * which uses: prefix, indentation, separator, suffix, and commentStyle.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     const { outputReferences } = options;
 *     const formatProperty = createPropertyFormatter({
 *       outputReferences,
 *       dictionary,
 *       format: 'css'
 *     });
 *     return dictionary.allTokens.map(formatProperty).join('\n');
 *   }
 * });
 * ```
 * @param {Object} options
 * @param {Boolean} options.outputReferences - Whether or not to output references. You will want to pass this from the `options` object sent to the formatter function.
 * @param {Boolean} options.outputReferenceFallbacks - Whether or not to output css variable fallback values when using output references. You will want to pass this from the `options` object sent to the formatter function.
 * @param {Dictionary} options.dictionary - The dictionary object sent to the formatter function
 * @param {String} options.format - Available formats are: 'css', 'sass', 'less', and 'stylus'. If you want to customize the format and can't use one of those predefined formats, use the `formatting` option
 * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. The configurable strings are: prefix, indentation, separator, suffix, and commentStyle. Those are used to generate a line like this: `${indentation}${prefix}${prop.name}${separator} ${prop.value}${suffix}`
 * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.
 * @returns {Function}
 */
function createPropertyFormatter$1({
  outputReferences = false,
  outputReferenceFallbacks = false,
  dictionary,
  format,
  formatting = {},
  themeable = false
}) {
  let {prefix, commentStyle, indentation, separator, suffix} = Object.assign({}, defaultFormatting$2, formatting);

  switch(format) {
    case 'css':
      prefix = '--';
      indentation = '  ';
      separator = ':';
      break;
    case 'sass':
      prefix = '$';
      commentStyle = 'short';
      indentation = '';
      separator = ':';
      break;
    case 'less':
      prefix = '@';
      commentStyle = 'short';
      indentation = '';
      separator = ':';
      break;
    case 'stylus':
      prefix = '$';
      commentStyle = 'short';
      indentation = '';
      separator = '=';
      break;
  }

  return function(prop) {
    let to_ret_prop = `${indentation}${prefix}${prop.name}${separator} `;
    let value = prop.value;

    /**
     * A single value can have multiple references either by interpolation:
     * "value": "{size.border.width.value} solid {color.border.primary.value}"
     * or if the value is an object:
     * "value": {
     *    "size": "{size.border.width.value}",
     *    "style": "solid",
     *    "color": "{color.border.primary.value"}
     * }
     * This will see if there are references and if there are, replace
     * the resolved value with the reference's name.
     */
    if (outputReferences && dictionary.usesReference(prop.original.value)) {
      // Formats that use this function expect `value` to be a string
      // or else you will get '[object Object]' in the output
      if (typeof value === 'string') {
        const refs = dictionary.getReferences(prop.original.value);
        refs.forEach(ref => {
          // value should be a string that contains the resolved reference
          // because Style Dictionary resolved this in the resolution step.
          // Here we are undoing that by replacing the value with
          // the reference's name
          if (ref.value && ref.name) {
            value = value.replace(ref.value, function() {
              if (format === 'css') {
                if (outputReferenceFallbacks) {
                  return `var(${prefix}${ref.name}, ${ref.value})`;
                } else {
                  return `var(${prefix}${ref.name})`;
                }
              } else {
                return `${prefix}${ref.name}`;
              }
            });
          }
        });
      }
    }

    to_ret_prop += prop.attributes.category === 'asset' ? `"${value}"` : value;

    const themeable_prop = typeof prop.themeable === 'boolean' ? prop.themeable : themeable;
    if (format === 'sass' && themeable_prop) {
      to_ret_prop += ' !default';
    }

    to_ret_prop += suffix;

    if (prop.comment && commentStyle !== 'none') {
      if (commentStyle === 'short') {
        to_ret_prop = to_ret_prop.concat(` // ${prop.comment}`);
      } else {
        to_ret_prop = to_ret_prop.concat(` /* ${prop.comment} */`);
      }
    }

    return to_ret_prop;
  }
}

var createPropertyFormatter_1 = createPropertyFormatter$1;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

// no-op default
const defaultFileHeader = (arr) => arr;

const lineSeparator = `\n`;
const defaultFormatting$1 = {
  lineSeparator,
  prefix: ` * `,
  header: `/**${lineSeparator}`,
  footer: `${lineSeparator} */${lineSeparator}${lineSeparator}`
};

/**
 *
 * This is for creating the comment at the top of generated files with the generated at date.
 * It will use the custom file header if defined on the configuration, or use the
 * default file header.
 * @memberof module:formatHelpers
 * @param {Object} options
 * @param {File} options.file - The file object that is passed to the formatter.
 * @param {String} options.commentStyle - The only options are 'short' and 'xml', which will use the // or \<!-- --> style comments respectively. Anything else will use \/\* style comments.
 * @param {Object} options.formatting - Custom formatting properties that define parts of a comment in code. The configurable strings are: prefix, lineSeparator, header, and footer.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, file }) {
 *     return fileHeader({file, commentStyle: 'short'}) +
 *       dictionary.allTokens.map(token => `${token.name} = ${token.value}`)
 *         .join('\n');
 *   }
 * });
 * ```
 */
function fileHeader({file={}, commentStyle, formatting={}}) {
  // showFileHeader is true by default
  let showFileHeader = true;
  if (file.options && typeof file.options.showFileHeader !== 'undefined') {
    showFileHeader = file.options.showFileHeader;
  }

  // Return empty string if the showFileHeader is false
  if (!showFileHeader) return '';

  let fn = defaultFileHeader;
  if (file.options && typeof file.options.fileHeader === 'function') {
    fn = file.options.fileHeader;
  }

  // default header
  const defaultHeader = [
    `Do not edit directly`,
    `Generated on ${new Date().toUTCString()}`
  ];


  let {prefix, lineSeparator, header, footer} = Object.assign({}, defaultFormatting$1, formatting);

  if (commentStyle === 'short') {
    prefix = `// `;
    header = `${lineSeparator}`;
    footer = `${lineSeparator}${lineSeparator}`;
  } else if (commentStyle === 'xml') {
    prefix = `  `;
    header = `<!--${lineSeparator}`;
    footer = `${lineSeparator}-->`;
  }

  return `${header}${fn(defaultHeader)
    .map(line => `${prefix}${line}`)
    .join(lineSeparator)}${footer}`;
}

var fileHeader_1 = fileHeader;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * A function that returns a sorting function to be used with Array.sort that
 * will sort the allTokens array based on references. This is to make sure
 * if you use output references that you never use a reference before it is
 * defined.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * dictionary.allTokens.sort(sortByReference(dictionary))
 * ```
 * @param {Dictionary} dictionary
 * @returns {Function}
 */
 function sortByReference$1(dictionary) {
  // The sorter function is recursive to account for multiple levels of nesting
  function sorter(a, b) {
    const aComesFirst = -1;
    const bComesFirst = 1;

    // If token a uses a reference and token b doesn't, b might come before a
    // read on..
    if (a.original && dictionary.usesReference(a.original.value)) {
      // Both a and b have references, we need to see if the reference each other
      if (b.original && dictionary.usesReference(b.original.value)) {
        const aRefs = dictionary.getReferences(a.original.value);
        const bRefs = dictionary.getReferences(b.original.value);

        aRefs.forEach(aRef => {
          // a references b, we want b to come first
          if (aRef.name === b.name) {
            return bComesFirst;
          }
        });

        bRefs.forEach(bRef => {
          // ditto but opposite
          if (bRef.name === a.name) {
            return aComesFirst;
          }
        });

        // both a and b have references and don't reference each other
        // we go further down the rabbit hole (reference chain)
        return sorter(aRefs[0], bRefs[0]);
      // a has a reference and b does not:
      } else {
        return bComesFirst;
      }
    // a does not have a reference it should come first regardless if b has one
    } else {
      return aComesFirst;
    }
  }

  return sorter;
}

var sortByReference_1 = sortByReference$1;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const createPropertyFormatter = createPropertyFormatter_1;
const sortByReference = sortByReference_1;

const defaultFormatting = {
  lineSeparator: '\n',
};

/**
 *
 * This is used to create lists of variables like Sass variables or CSS custom properties
 * @memberof module:formatHelpers
 * @param {Object} options
 * @param {String} options.format - What type of variables to output. Options are: css, sass, less, and stylus
 * @param {Object} options.dictionary - The dictionary object that gets passed to the formatter method.
 * @param {Boolean} options.outputReferences - Whether or not to output references
 * @param {Object} options.formatting - Custom formatting properties that define parts of a declaration line in code. This will get passed to `formatHelpers.createPropertyFormatter` and used for the `lineSeparator` between lines of code.
 * @param {Boolean} options.themeable [false] - Whether tokens should default to being themeable.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return formattedVariables('less', dictionary, options.outputReferences);
 *   }
 * });
 * ```
 */
function formattedVariables({ format, dictionary, outputReferences = false, formatting = {}, themeable = false}) {
  let {allTokens} = dictionary;

  let {lineSeparator} = Object.assign({}, defaultFormatting, formatting);

  // Some languages are imperative, meaning a variable has to be defined
  // before it is used. If `outputReferences` is true, check if the token
  // has a reference, and if it does send it to the end of the array.
  // We also need to account for nested references, a -> b -> c. They
  // need to be defined in reverse order: c, b, a so that the reference always
  // comes after the definition
  if (outputReferences) {
    // note: using the spread operator here so we get a new array rather than
    // mutating the original
    allTokens = [...allTokens].sort(sortByReference(dictionary));
  }

  return allTokens
    .map(createPropertyFormatter({ outputReferences, dictionary, format, formatting, themeable }))
    .filter(function(strVal) { return !!strVal })
    .join(lineSeparator);
}

var formattedVariables_1 = formattedVariables;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const ChangeCase = require$$0;

const reduce = function(obj, f, accumulator_init) {
  return Object.keys(obj || {}).reduce((accumulator, key) => {
    let value = obj[key];
    return f(accumulator, value, key, obj)
  }, accumulator_init)
};

const forEach = function(obj, f) {
  Object.keys(obj || {}).forEach((key) => {
    let value = obj[key];
    f(value, key);
  });
};

// Note: This is a crappy version to a certain extent... don't use with Strings, for example...
const clone = function(object) {
  return Object.assign(new object.constructor(), object)
};

const cloneDeep = function(obj) {
  if(obj === null || obj === undefined || typeof obj !== 'object') {
    return obj
  }

  if(obj instanceof Array) {
    return obj.reduce((arr, item, i) => {
      arr[i] = cloneDeep(item);
      return arr
    }, [])
  }

  if(obj instanceof Object) {
    return Object.keys(obj || {}).reduce((cpObj, key) => {
      cpObj[key] = cloneDeep(obj[key]);
      return cpObj
    }, {})
  }
};

const isObject = function(value) {
  const type = typeof value;
  return value != null && (type === 'object' || type === 'function')
};

const isString = function(obj) {
  return typeof obj === 'string' || obj instanceof String
};

const isArray = function(obj) {
  return Array.isArray(obj)
};

const isEmpty = function(obj) {
  return [Object, Array].includes((obj || {}).constructor) && !Object.entries((obj || {})).length
};

function isPlainObject(value) {
  if (typeof value !== 'object' || value === null || Object.prototype.toString.call(value) !== '[object Object]') {
    return false
  }
  if (Object.getPrototypeOf(value) === null) {
    return true
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto
}

const filter = function (arr, filter) {
  if (typeof(filter) !== 'function') {
    throw("filter is not a function")
  }
  if (typeof arr === 'undefined') {
    return []
  }
  return arr.filter(filter)
};

const assign = function () {
  let args = Array.prototype.slice.call(arguments);
  args.unshift({});
  return Object.assign(...args)
};

/* global Set */
const pull = function (arr, ...removeList){
  var removeSet = new Set(removeList);
  for (let i=arr.length-1;i>=0;i--) {
      if (removeSet.has(arr[i])) {
        arr.splice(i, 1);
      }
  }
};

const unique$1 = function (arr){
  return [...new Set(arr)]
};

const upperFirst = function (str) {
  return str ? str[0].toUpperCase() + str.substr(1) : ''
};

const matchFn = function(inputObj, testObj) {
  if (isObject(testObj)) {
    return Object.keys(testObj).every((key) => matchFn(inputObj[key], testObj[key]))
  }
  else {
    return inputObj == testObj
  }
};

const matches = function (matchObj) {
  let cloneObj = cloneDeep(matchObj);
  let matchesFn = (inputObj) => matchFn(inputObj, cloneObj);
  return matchesFn
};

const DEFAULT_OPTIONS = {
  transform: ChangeCase.camelCaseTransformMerge
};
const changeDefaultCaseTransform = function (caseFunction, default_options) {
  return (caseToChange, options) => caseFunction(caseToChange, Object.assign({}, DEFAULT_OPTIONS, default_options, options))
};

var es6_ = {
  each: forEach,
  forEach: forEach,
  forIn: forEach,
  keys: Object.keys,
  clone: clone,
  cloneDeep: cloneDeep,
  extend: Object.assign,
  isString: isString,
  isArray: isArray,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isEmpty: isEmpty,
  filter: filter,
  reduce: reduce,
  assign: assign,
  upperFirst: upperFirst,
  camelCase: changeDefaultCaseTransform(ChangeCase.camelCase),
  snakeCase: ChangeCase.snakeCase,
  kebabCase: ChangeCase.paramCase,
  pull: pull,
  matches: matches,
  unique: unique$1,
};

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

const { unique } = es6_;

/**
 * Given some value, returns a basic valid TypeScript type for that value.
 * Supports numbers, strings, booleans, arrays and objects of any of those types.
 *
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *    return dictionary.allProperties.map(function(prop) {
 *      var to_ret_prop = 'export const ' + prop.name + ' : ' + getTypeScriptType(prop.value) + ';';
 *      if (prop.comment)
 *        to_ret_prop = to_ret_prop.concat(' // ' + prop.comment);
 *      return to_ret_prop;
 *    }).join('\n');
 *   }
 * });
 *
 * @param {*} value A value to check the type of.
 * @return {String} A valid name for a TypeScript type.
 * ```
 */
 function getTypeScriptType(value)  {
  if (Array.isArray(value)) return getArrayType(value)
  if (typeof value === 'object') return getObjectType(value)
  if (['string', 'number', 'boolean'].includes(typeof value)) return typeof value

  return 'any'
}

/**
 * @param {Object} value An object with uknown type properties
 * @returns {String} A representation of the type model for the passed object
 */
function getObjectType(value)  {
  const entries = Object.entries(value);
  return `{ ${entries.map(([key, property], index) => {
    const isLast = entries.length === index + 1;
    return `${key}: ${getTypeScriptType(property)}${!isLast ? ', ' : ''}`
  }).join('')} }`
}

/**
 * @param {Array} value An array to check each property of
 * @returns {String} A valid type for the passed array and it's items
 */
function getArrayType(passedArray)  {
  if (passedArray.length > 0) {
    const firstValueType = getTypeScriptType(passedArray[0]);
    if (passedArray.every((v) => getTypeScriptType(v) === firstValueType)) {
      return firstValueType + '[]';
    } else {
      return `(${unique(passedArray.map((item, index) => {
        const isLast = passedArray.length === index + 1;
        return `${getTypeScriptType(item)}${!isLast ? ' | ' : ''}`
      })).join('')})[]`
    }
  }
  return 'any[]';
}

var getTypeScriptType_1 = getTypeScriptType;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 *
 * This is used to create CSS (and CSS pre-processor) lists of icons. It assumes you are
 * using an icon font and creates helper classes with the :before pseudo-selector to add
 * a unicode character.
 * __You probably don't need this.__
 * @memberof module:formatHelpers
 * @param {String} prefix - Character to prefix variable names, like '$' for Sass
 * @param {Token[]} allTokens - allTokens array on the dictionary object passed to the formatter function.
 * @param {Object} options - options object passed to the formatter function.
 * @returns {String}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return iconsWithPrefix('$', dictionary.allTokens, options);
 *   }
 * });
 * ```
 */
 function iconsWithPrefix(prefix, allTokens, options) {
  return allTokens.filter(function(token) {
      return token.attributes.category === 'content' && token.attributes.type === 'icon';
    })
    .map(function(token) {
      var varName = prefix + token.name + ': ' + token.value + ';';
      var className = '.' + options.prefix + '-icon.' + token.attributes.item + ':before ';
      var declaration = '{ content: ' + prefix + token.name + '; }';
      return varName + '\n' + className + declaration;
    })
    .join('\n');
}

var iconsWithPrefix_1 = iconsWithPrefix;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * A sorting function to be used when iterating over `dictionary.allTokens` in
 * a format.
 * @memberof module:formatHelpers
 * @example
 * ```javascript
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary, options }) {
 *     return dictionary.allTokens.sort(sortByName)
 *       .map(token => `${token.name} = ${token.value}`)
 *       .join('\n');
 *   }
 * });
 * ```
 * @param {*} a - first element for comparison
 * @param {*} b - second element for comparison
 * @returns {Integer} -1 or 1 depending on which element should come first based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 */
function sortByName(a,b) {
  if (b.name > a.name) {
    return -1
  } else {
    return 1
  }
}

var sortByName_1 = sortByName;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Outputs an object stripping out everything except values
 * @memberof module:formatHelpers
 * @param {Object} obj - The object to minify. You will most likely pass `dictionary.tokens` to it.
 * @returns {Object}
 * @example
 * ```js
 * StyleDictionary.registerFormat({
 *   name: 'myCustomFormat',
 *   formatter: function({ dictionary }) {
 *     return JSON.stringify(minifyDictionary(dictionary.tokens));
 *   }
 * });
 * ```
 */
 function minifyDictionary(obj) {
  if (typeof obj !== 'object' || Array.isArray(obj)) {
    return obj;
  }

  var toRet = {};

  if (obj.hasOwnProperty('value')) {
    return obj.value;
  } else {
    for(var name in obj) {
      if(obj.hasOwnProperty(name)) {
        toRet[name] = minifyDictionary(obj[name]);
      }
    }
  }
  return toRet;
}

var minifyDictionary_1 = minifyDictionary;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 * Outputs an object with swift format configurations. Sets import, object type and access control.
 * @memberof module:formatHelpers
 * @param {Object} options - The options object declared at configuration
 * @param {String} objectType - The type of the object in the final file. Could be a class, enum, struct, etc.
 * @param {String} transformGroup - The transformGroup of the file, so it can be applied proper import
 * @returns {Object}
 */
function setSwiftFileProperties(options, objectType, transformGroup) {
  if (typeof options.objectType === 'undefined') {
    if (typeof objectType === 'undefined') {
      options.objectType = 'class';
    } else {
      options.objectType = objectType;
    }
  }

  if (typeof options.import === 'undefined') {
    if (typeof transformGroup === 'undefined') {
      options.import = ['UIKit'];
    } else if (['ios-swift', 'ios-swift-separate'].includes(transformGroup)) {
      options.import = ['UIKit'];
    } else {
      // future swift-ui transformGroup to be added here
      options.import = ['SwiftUI'];
    }
  } else if (typeof options.import === 'string') {
    options.import = [options.import];
  }

  if (typeof options.accessControl === 'undefined') {
    options.accessControl = 'public ';
  } else {
    if (options.accessControl !== "") {
      options.accessControl = `${options.accessControl} `;
    }
  }

  return options
}

var setSwiftFileProperties_1 = setSwiftFileProperties;

/*
 * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

/**
 *
 * @module formatHelpers
 */
 var formatHelpers$1 = {
  createPropertyFormatter: createPropertyFormatter_1,
  fileHeader: fileHeader_1,
  formattedVariables: formattedVariables_1,
  getTypeScriptType: getTypeScriptType_1,
  iconsWithPrefix: iconsWithPrefix_1,
  sortByReference: sortByReference_1,
  sortByName: sortByName_1,
  minifyDictionary: minifyDictionary_1,
  setSwiftFileProperties: setSwiftFileProperties_1
};

var formatHelpers = formatHelpers$1;

export { formatHelpers as default };

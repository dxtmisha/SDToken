import getReferences from '../../bundled_CJS_deps/style-dictionary/lib/utils/references/getReferences.js';
import usesReference from '../../bundled_CJS_deps/style-dictionary/lib/utils/references/usesReference.js';
import { expandablesAsStringsArr } from '../TransformOptions.js';

// @ts-expect-error no type exported for this function
const typeMaps = {
    boxShadow: {
        x: 'dimension',
        y: 'dimension',
        blur: 'dimension',
        spread: 'dimension',
        type: 'other',
    },
    border: {
        width: 'borderWidth',
        style: 'other',
    },
    composition: {},
    typography: {
        fontFamily: 'fontFamilies',
        fontWeight: 'fontWeights',
        lineHeight: 'lineHeights',
        fontSize: 'fontSizes',
        fontStyle: 'fontStyles',
    },
};
function expandToken(compToken, isShadow = false) {
    const expandedObj = {};
    const getType = (key) => typeMaps[compToken.type][key] ?? key;
    // multi-shadow
    if (isShadow && Array.isArray(compToken.value)) {
        compToken.value.forEach((shadow, index) => {
            expandedObj[index + 1] = {};
            Object.entries(shadow).forEach(([key, value]) => {
                expandedObj[index + 1][key] = {
                    value: `${value}`,
                    type: getType(key),
                };
            });
        });
    }
    else {
        Object.entries(compToken.value).forEach(([key, value]) => {
            expandedObj[key] = {
                value: `${value}`,
                type: getType(key),
            };
        });
    }
    return expandedObj;
}
function shouldExpand(token, condition, filePath) {
    if (typeof condition === 'function') {
        return condition(token, filePath);
    }
    return condition;
}
function recurse(slice, filePath, transformOpts = {}, boundGetRef) {
    const opts = {
        ...transformOpts,
        expand: {
            composition: true,
            typography: false,
            border: false,
            shadow: false,
            ...(transformOpts.expand || {}),
        },
    };
    for (const key in slice) {
        const token = slice[key];
        const { type } = token;
        if (token.value && type) {
            if (typeof type === 'string' && expandablesAsStringsArr.includes(type)) {
                const expandType = type === 'boxShadow' ? 'shadow' : type;
                const expand = shouldExpand(token, opts.expand[expandType], filePath);
                if (expand) {
                    // if token uses a reference, resolve it
                    if (typeof token.value === 'string' && usesReference(token.value)) {
                        let ref = { value: token.value };
                        while (ref && ref.value && typeof ref.value === 'string' && usesReference(ref.value)) {
                            // boundGetRef = getReferences() but bound to this style-dictionary object during parsing
                            // this spits back either { value: '{deepRef}' } if it's a nested reference or
                            // the object value (typography/composition/border/shadow)
                            // However, when it's the final resolved value, the props are as { value, type }
                            // instead of just the value, so we use a map to grab only the value...
                            try {
                                ref = Object.fromEntries(Object.entries(boundGetRef(ref.value)[0]).map(([k, v]) => [k, v.value]));
                            }
                            catch (e) {
                                console.warn(`Warning: could not resolve reference ${ref.value}`);
                                return;
                            }
                        }
                        token.value = ref;
                    }
                    slice[key] = expandToken(token, expandType === 'shadow');
                }
            }
        }
        else if (typeof token === 'object') {
            // TODO: figure out why we have to hack this typecast, if a value doesn't have a value & type,
            // it is definitely a nested DeepKeyTokenMap and not a SingleToken, but TS seems to think it must be
            // a SingleToken after this if statement
            recurse(token, filePath, transformOpts, boundGetRef);
        }
    }
}
function expandComposites(dictionary, filePath, transformOpts) {
    const copy = { ...dictionary };
    const boundGetRef = getReferences.bind({ properties: copy });
    recurse(copy, filePath, transformOpts, boundGetRef);
    return copy;
}

export { expandComposites, expandToken };
